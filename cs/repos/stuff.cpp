
#- * - coding : utf - 8 - * -
""
    "Copy of SulfurSensorCode.ipynb

    Automatically generated by Colab.

    Original file is located at https
    : // colab.research.google.com/drive/1VZk8l1ahk_6UV-JtWtxz70yxdPBMtqhP

#C++ Code

      ##Class def ""
                  "

/*
  ULP.h - Library for reading SPEC Sensors ULP.
  Revised by David E. Peaslee, May 22, 2020.
  Created by David E. Peaslee, OCT 27, 2016.
  Released into the public domain.
*/
#ifndef ULP_h
#define ULP_h

#include "Arduino.h"

      class ULP {
  ##class definition

      private :##not availble outside of the class const int pCPin,
               pTPin; ##the pin numbers for ADC read

    //temperature sensor settings
    float pHtemp;
  float pLtemp; // temps for cal of temp sensor
  float pHvolt; // volts for cal of temp sensor
  float pLvolt; // volts for cal of temp sensor

public:
  // gas sensor settings
  float pSf;         // initializers for sensor
  float pVcc = 5.0;  // analog read reference voltage, usually 5 V for Uno
  float pVsup = 3.3; // voltage supplied to ULP, !!!! max 3.3 V !!!!
  float pVref_set;   // initially set to pVref, then reset to include V of open
                   // circuit voltage during OCzero()
  float pVref; // vref is voltage divider, this is set ideally voltage with no
               // current through circuit (electronic zero)
  float pInA;  // the last calculated value of current for the sensor
  float pVgas; // the last measured value of voltage for the sensor
  float pT;    // the last calculated value of temperature in degrees C
  float pX;    // the last calculated value of concentration in ppb

  // temperature sensor settings
  float pTb; // temperature sensor coef
  float pTs; // temperature sensor coef

  // temperature correction coefficient
  float pTc;    // sensitivity coeficient
  float pn;     // exponential correction to baseline
  float pIzero; // exponential coeficeient to correction to baseline reset
                // during zero()
  float pTzero; // exponential zero temperature factor

  float pGain; // gain of trans impedance amplifier (TIA)

  ULP(int a, int b, float c);

  float convertT(char U = 'C'); // output T in F or C

  float convertX(char U = 'B'); // output X in ppm or ppb

  float expI(float T); // custom exponential function

  void getTemp(int n); // ADC read to calculate temp

  void getConc(float t = 20.0); // ADC of sensor voltage, converted to current
                                // then corrected for temperature and gas

  void setVref(int b, long R2); // basic setting to calculate initial offset,
                                // good for expected high levels of gas

  void zero(); // Measure current values and store Izero and Tzero for
               // temperature correction of baseline

  bool OCzero(int n = 10); // Measure differential of open circuit voltage, used
                           // for precise ADC measurments

  void getIgas(int n); // ADC of sensor voltage, converted to current

  void setXSpan(); // not recomended for use, simple calibration of gas
                   // concentration, input is expected gas concentration

  void setTSpan(float t, String R); // simple calibration of temperature sensor
};

class SPEC : public ULP {
public:
  SPEC(int a, int b, float c = 1.0);
};

class EtOH : public ULP {
public:
  EtOH(int a, int b, float c = 14.0);
};

class H2S : public ULP {
public:
  H2S(int a, int b, float c = 194.0);
};

class CO : public ULP {
public:
  CO(int a, int b, float c = 2.44);
};

class IAQ : public ULP {
public:
  IAQ(int a, int b, float c = 150.0);
};

class SO2 : public ULP {
public:
  SO2(int a, int b, float c = 14.6);
};

class NO2 : public ULP {
public:
  NO2(int a, int b, float c = -25.0);
};

class RESP : public ULP {
public:
  RESP(int a, int b, float c = -21.5);
};

class O3 : public ULP {
public:
  O3(int a, int b, float c = -20.0);
};

#endif

""
    "##cpp for arduino"
    ""

#include "Arduino.h"
#include "ULP.h"

    ULP::ULP(int a, int b, float c)
    : pCPin(a), pTPin(b), pSf(c) {

  pTzero = 20.0;
  pIzero = 0.0;

  // Temperature Sensor Settings
  pHtemp = 40.0;
  pLtemp = 20.0;                         // temps for cal of temp sensor
  pTb = 18.0;                            // temperature sensor coef
  pTs = 87.0;                            // temperature sensor coef
  pHvolt = (pHtemp + pTb) * pVsup / pTs; // volts for cal of temp sensor
  pLvolt = (pLtemp + pTb) * pVsup / pTs; // volts for cal of temp sensor
}

// float ULP::pVcc = 5.0;
// float ULP::pVsup = 3.3;

void ULP::getTemp(int n) {
  unsigned long etime, i = 0;
  unsigned long anaCounts = 0;
  etime = millis() + n * 1000;
  do {
    anaCounts = anaCounts + analogRead(pTPin);
    delay(1);
    i++;
  } while (millis() < etime);
  float Cnts = float(anaCounts) / float(i);
  float Volts = Cnts * pVcc / 1024.0;

  pT = (pTs / pVsup) * Volts - pTb;
}

float ULP::convertT(char U) {
  if (U == 'F') {
    float TempF = pT * 9 / 5 + 32;
    return TempF;
  } else if (U == 'C') {
    return pT;
  } else
    return 0;
}

float ULP::convertX(char U) {
  if (U == 'B')
    return pX;
  else if (U == 'M')
    return (pX / 1000.0);
  else
    return 0;
}

void ULP::setTSpan(float t, String R) {
  Serial.print("Old temp. span and offset: ");
  Serial.print(pTs);
  Serial.print(", ");
  Serial.println(pTb);
  unsigned long etime, i = 0, n = 10;
  unsigned long anaCounts = 0;
  etime = millis() + n * 1000;
  do {
    anaCounts = anaCounts + analogRead(pTPin);
    delay(1);
    i++;
  } while (millis() < etime);
  float Cnts = float(anaCounts) / float(i);
  float Volts = Cnts * pVcc / 1024;

  if (R == "HIGH") {
    pHtemp = t;
    pHvolt = Volts;
  } else if (R == "LOW") {
    pLtemp = t;
    pLvolt = Volts;
  }
  pTs = pVsup * (pHtemp - pLtemp) / (pHvolt - pLvolt);
  pTb = pLvolt * (pHtemp - pLtemp) / (pHvolt - pLvolt) - pLtemp;
  Serial.print("New temp. span and offset: ");
  Serial.print(pTs);
  Serial.print(", ");
  Serial.println(pTb);
}

void ULP::setVref(int b, long R2) {
  // Caluclate Expected Vref
  if (b >= 0)
    pVref = pVsup * float(R2 + 1000000) / float(R2 + 2000000) * 1000.0;
  else
    pVref = pVsup * float(1000000) / float(R2 + 2000000) * 1000.0;
  pVref_set = pVref;
}

bool ULP::OCzero(int n) {
  // Measure real Vref
  unsigned long etime, i = 0;
  unsigned long anaCounts = 0;
  Serial.println("Send any character when sensor is removed.");
  while (Serial.available() <= 0) {
  }
  Serial.println("Zeroing");
  Serial.flush();
  etime = millis() + n * 1000;
  do {
    anaCounts = anaCounts + analogRead(pCPin);
    delay(1);
    i++;
  } while (millis() < etime);
  float Cnts = float(anaCounts) / float(i);
  pVref_set = Cnts * pVcc * 1000.0 / 1024.0; // in mV
  Serial.println(abs(pVref - pVref_set));

  if (abs(pVref - pVref_set) > 50)
    return false;
  else
    return true;
}

void ULP::zero() {
  pIzero = pInA;
  pTzero = pT;
}

void ULP::getIgas(int n) {
  unsigned long etime, i = 0;
  unsigned long anaCounts = 0;
  etime = millis() + n * 1000;
  do {
    anaCounts = anaCounts + analogRead(pCPin);
    delay(1);
    i++;
  } while (millis() < etime);
  float Cnts = float(anaCounts) / float(i);

  pVgas = Cnts * pVcc * 1000.0 / 1024.0;       // in mV
  pInA = (pVgas - pVref_set) / pGain * 1000.0; // in nA
}

void ULP::getConc(float t) {
  float nA = pInA - pIzero * expI(t - pTzero);
  float Sens = pSf * (1.0 + pTc * (t - 20.0));
  pX = nA / Sens * 1000.0; // output in ppb
}

float ULP::expI(float T) { return exp(T / pn); }

void ULP::setXSpan() {
  Serial.setTimeout(10000);
  float X;
  float nA, Sf;
  Serial.print("When gas concentration steady, enter Concentration in ppm "
               "followed by 'cr' = ");
  while (Serial.available() <= 0) {
  }
  X = Serial.parseFloat();
  Serial.println(X);
  getIgas(10);

  Sf = pInA / X;
  if (abs(Sf - pSf) * 2 / (Sf + pSf) < .1) {
    pSf = Sf;
  } else {
    Serial.println("Error Setting Span");
  }
}

EtOH::EtOH(int a, int b, float c) : ULP(a, b, c = 14.0) {
  setVref(+100, 69800);
  pGain = 249.0;
  pn = 1;
  pTc = 0.01;
}

H2S::H2S(int a, int b, float c) : ULP(a, b, c = 194.0) { // works
  setVref(+3, 2000);
  pGain = 49.9;
  pn = -300.0;
  pTc = 0.007;
}

CO::CO(int a, int b, float c) : ULP(a, b, c = 2.44) {
  setVref(+3, 2000);
  pGain = 100.0;
  pn = 13.6;
  pTc = 0.007;
}

IAQ::IAQ(int a, int b, float c) : ULP(a, b, c = 150.0) {
  setVref(+150, 105000);
  pGain = 100.0;
  pn = 1;
  pTc = 0.01;
}

SO2::SO2(int a, int b, float c) : ULP(a, b, c = 14.6) {
  setVref(+200, 143000);
  pGain = 100.0;
  pn = 10.26;
  pTc = -0.026;
}

NO2::NO2(int a, int b, float c) : ULP(a, b, c = -25.0) {
  setVref(-25, 16200);
  pGain = 499.0;
  pn = 109.6;
  pTc = 0.005;
}

RESP::RESP(int a, int b, float c) : ULP(a, b, c = -21.5) {
  setVref(-200, 143000);
  pGain = 499.0;
  pn = 1;
  pTc = 0.00;
}

O3::O3(int a, int b, float c) : ULP(a, b, c = -20.0) {
  setVref(-25, 16200);
  pGain = 499.0;
  pn = 109.6;
  pTc = -0.005;
}

SPEC::SPEC(int a, int b, float c) : ULP(a, b, c = 1.0) {}

""
    "##example .ino"
    ""

/*
  ULP.cpp - Library for reading SPEC Sensors ULP.
  Revised by David E. Peaslee, May 22, 2020.
  Created by David E. Peaslee, OCT 27, 2016.
  Released into the public domain.
*/

#include "Arduino.h"
#include "ULP.h"

    // These constants won't change.  They're used to give names to the pins
    // used and to the sensitivity factors of the sensors:

    const int C1 = A0;
const int T1 = A3;
// averaging times, keep these low, so that the ADC read does not overflow 32
// bits. For example n = 5 reads ADC 4465 times which could add to 22bit number.
const int n = 5; // number of seconds to read gas sensor
const int m = 1; // number of seconds to read temperature sensor
const int s =
    10; // number of seconds to read all sensors should be greater than n+m+1

const float Sf1 = 11.61; // nA/ppm change this to match your barcode!!!!

unsigned long etime;

SO2 sensor1(C1, T1, Sf1); // Sensor Types are EtoH, H2S, CO, IAQ, SO2, NO2,
                          // RESP, O3, and SPEC (custom)
// O3 sensor2(C2, T2, Sf2);  //Example O3
// CO sensor3(C3, T3, Sf3);  //Example CO

//  Include these if using different boards with different voltages

void setup() {
  // uncomment only after you have connected 3.3V to Aref on the arduino
  // analogReference(EXTERNAL);
  // sensor1.pVcc = 3.31;  //analogRead Reference Voltage, equal to pVsup when
  // analogReference uses same voltage as sensor power

  sensor1.pVcc = 5.04;  // analogRead Reference Voltage, maybe measure Aref??
  sensor1.pVsup = 3.31; // voltage supplied to V+ of ULP, default is 3.3 Volts,
                        // probably should measure this as well.

  Serial.flush();
  Serial.begin(9600); // initialize serial communications at 9600 bps:

  Serial.println();
  Serial.println("Setting Up.");

  Serial.print("Vsup for all sensors = ");
  Serial.println(sensor1.pVsup);
  Serial.print("Vcc for all sensors = ");
  Serial.println(sensor1.pVcc);
  Serial.print("Vref for sensor 1 = ");
  Serial.println(sensor1.pVref);

  //  Using resistor values from board R1, R2, R3 are for setting pVref and
  //  Bias, while R6 sets the gain If using modified or custom boards set Vref
  //  and Gain like this
  // long int R2 = 1000;  //Assumes R1 and R3 are 1 MOhms in resistor ladder
  // float bias = -25.0
  // sensor2.setVref(bias, R2);
  // sensor2.pGain = 100000; //resistor R6

  // if you know the V_ref replace the following code...
  Serial.println("Remove Sensor.");
  if (sensor1.OCzero(n)) {
    Serial.print("Vref new = ");
    Serial.println(sensor1.pVref_set);
  } else {
    Serial.println("Recheck Settings, Zero out of range");
    while (1) {
      Serial.println(analogRead(A0));
      delay(1000);
    }
  }
  //...with this code and your measured value of new Vref
  // sensor1.pVref_set = ????

  // sensor1.setXSpan();                                //Must have previously
  // zeroed in clean air, returns new span factor.

  // When calibrating the temperature use "LOW"/"HIGH" for the temperature range
  // ie .setTSpan(40.2, "HIGH") where T is the current high temperature
  // sensor1.setTSpan((71 - 32.0) * 5.0 / 9.0, "LOW");

  Serial.println("Finished Setting Up, Replace Sensor Now.");
  Serial.println("T1, mV, nA, C1");
  etime = millis();
}

void loop() {

  while (Serial.available()) {
    if (Serial.read() == 'Z') {
      Serial.println("Zeroing");
      sensor1.zero(); // Uses last values read of Izero and Tzero
      Serial.print("Izero, Tzero: ");
      Serial.print(sensor1.pIzero);
      Serial.print(", ");
      Serial.println(sensor1.pTzero);
    }
  }

  if (millis() - etime > (s * 1000)) { // also handles case where millis rolls
                                       // over, but may cause timing issue.
    etime = millis();

    sensor1.getIgas(n);
    sensor1.getTemp(m);
    sensor1.getConc(sensor1.pT);

    Serial.print(sensor1.convertT('C')); // use 'C' or 'F' for units
    Serial.print(", ");
    Serial.print(sensor1.pVgas);
    Serial.print(", ");
    Serial.print(sensor1.pInA);
    Serial.print(", ");
    Serial.println(
        sensor1.convertX('M')); // use 'M' or 'B' for units or
                                // Serial.println(sensor1.pX); to just print ppb
  }
}
